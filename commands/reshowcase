#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const os = require("os");
const esbuild = require("esbuild");
const { htmlPlugin } = require("@craftamap/esbuild-plugin-html");

const toAbsolutePath = (filepath) => {
  if (path.isAbsolute(filepath)) {
    return filepath;
  } else {
    return path.join(process.cwd(), filepath);
  }
};

const getRequiredPathValue = (name) => {
  const prefix = `--${name}=`;
  const arg = process.argv.find((item) => item.startsWith(prefix));
  if (arg === undefined) {
    console.error(`Please pass ${name} path: ${prefix}...`);
    process.exit(1);
  } else {
    const value = arg.replace(prefix, "");
    if (value === "") {
      console.error(`${name} path can't be empty`);
      process.exit(1);
    } else {
      return toAbsolutePath(value);
    }
  }
};

const task = process.argv[2];

if (task !== "build" && task !== "start") {
  console.error(
    "You need to pass 'start' or 'build' command and path to the entry point.\nFor example: reshowcase start --entry=./example/Demo.bs.js"
  );
  process.exit(1);
}

// Servers can handle paths to HTML files differently.
// Allow using full path to HTML template in "src" attribute of iframe in case of possible issues.
const useFullframeUrl = (() => {
  const prefix = `--full-iframe-url=`;
  const arg = process.argv.find((item) => item.startsWith(prefix));
  if (arg === undefined) {
    return false;
  } else {
    const value = arg.replace(prefix, "");
    if (value === "true") {
      return true;
    } else {
      return false;
    }
  }
})();

const isBuild = task === "build";

const entryPath = getRequiredPathValue("entry");

if (!fs.existsSync(entryPath)) {
  console.error(`Entry file not found here: ${entryPath}`);
  process.exit(1);
}

const outputPath = (() => {
  if (isBuild) {
    return getRequiredPathValue("output");
  } else {
    return os.tmpdir();
  }
})();

const customConfig = (() => {
  const configDir = path.join(process.cwd(), ".reshowcase");

  if (!fs.existsSync(configDir)) {
    return {};
  } else {
    const configFilenames = fs.readdirSync(configDir);
    const configFilename = configFilenames.find(
      (filename) => filename === "config.cjs" || filename === "config.js"
    );
    if (configFilename === undefined) {
      return {};
    } else {
      try {
        const pathToConfig = path.join(configDir, configFilename);
        const config_ = require(pathToConfig);
        return config_;
      } catch (error) {
        console.error("Failed to read config:", error);
        return {};
      }
    }
  }
})();

const watchPlugin = {
  name: "watchPlugin",
  setup: (build) => {
    build.onEnd((_buildResult) => console.log("[Esbuild] Rebuild finished!"));
  },
};

// entryPoint passed to htmlPlugin must be relative to the current working directory
const entryPathRelativeToCwd = path.relative(process.cwd(), entryPath);

const defaultConfig = {
  entryPoints: [entryPath],
  entryNames: "[name]-[hash]",
  assetNames: "[name]-[hash]",
  chunkNames: "[name]-[hash]",
  bundle: true,
  outdir: outputPath,
  publicPath: "/",
  format: "esm",
  minify: isBuild,
  metafile: true,
  splitting: true,
  treeShaking: true,
  logLevel: "warning",
  loader: Object.fromEntries(
    [
      ".css",
      ".jpg",
      ".jpeg",
      ".png",
      ".gif",
      ".svg",
      ".ico",
      ".avif",
      ".webp",
      ".woff",
      ".woff2",
      ".json",
      ".mp4",
    ].map((ext) => [ext, "file"])
  ),
  define: {
    USE_FULL_IFRAME_URL: JSON.stringify(isBuild ? useFullframeUrl : true),
  },
  plugins: [
    htmlPlugin({
      files: [
        {
          filename: "index.html",
          entryPoints: [entryPathRelativeToCwd],
          htmlTemplate: path.join(__dirname, "./ui-template.html"),
          scriptLoading: "module",
        },
        {
          filename: "./demo/index.html",
          entryPoints: [entryPathRelativeToCwd],
          htmlTemplate: process.argv.find((item) =>
            item.startsWith("--template=")
          )
            ? path.join(
                process.cwd(),
                process.argv
                  .find((item) => item.startsWith("--template="))
                  .replace(/--template=/, "")
              )
            : path.join(__dirname, "./demo-template.html"),
          scriptLoading: "module",
        },
      ],
    }),
    ...(isBuild ? [] : [watchPlugin]),
  ],
};

const getPort = () => {
  const defaultPort = 8000;
  const prefix = "--port=";
  const arg = process.argv.find((item) => item.startsWith(prefix));
  if (arg === undefined) {
    return defaultPort;
  } else {
    const portStr = arg.replace(prefix, "");
    if (portStr === "") {
      return defaultPort;
    } else {
      const parsed = parseInt(portStr, 10);
      return isNaN(parsed) ? defaultPort : parsed;
    }
  }
};

const config = {
  ...defaultConfig,
  ...customConfig,
  define: { ...defaultConfig.define, ...(customConfig.define || {}) },
  plugins: [...defaultConfig.plugins, ...(customConfig.plugins || [])],
};

if (isBuild) {
  const durationLabel = "[Reshowcase] Build finished. Duration";
  console.time(durationLabel);

  esbuild
    .build(config)
    .then((_buildResult) => {
      console.timeEnd(durationLabel);
    })
    .catch((error) => {
      console.error("[Reshowcase] Esbuild build failed:", error);
      process.exit(1);
    });
} else {
  const port = getPort();
  const durationLabel = "[Reshowcase] Watch and serve started. Duration";
  console.time(durationLabel);

  esbuild
    .context(config)
    .then((ctx) => {
      return ctx.watch().then(() => ctx);
    })
    .catch((error) => {
      console.error("[Reshowcase] Esbuild watch start failed:", error);
      process.exit(1);
    })
    .then((ctx) => {
      return ctx.serve({ port: port, servedir: outputPath });
    })
    .then((_serveResult) => {
      console.timeEnd(durationLabel);
      console.error("[Reshowcase] Watch mode started on port:", port);
    })
    .catch((error) => {
      console.error("[Reshowcase] Esbuild serve start failed:", error);
      process.exit(1);
    });
}
